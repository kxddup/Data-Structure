# 树与二叉树 Tree

[toc]

## ![image-20231127164926210](树与二叉树.assets/image-20231127164926210.png)

## 树概念及结构

### 1.1树概念

树Tree是一种**非线性**（nonlinear structure）

的数据结构，它是由n（n>=0）个有限结点组成一个<u>具有层次关系</u>的<u>有限集合</u>。 

（结点之间有分支）

(线性：1；1/非线性：树形 1：n

​                                        图形：m:n)

若n=0，称为空树；empty tree

若n>0,则满足如下两个条件：

1. [有且仅有]()一个特定的称为根（Root）的结点；

2. 其余结点可分为n（m>=0）个**互不相交**的有限集根的[子树]()（SubTree）

   &==树的定义是递归的，即在树的定义中又用到了自身，树是一种递归==
   
   ==的数据结构。==
   
   递归：Recursion

​			    & ==分层结构==，具有以下两个特点：

1. 树的<u>根结点</u>没有前驱，除根结点外的所有结点有且只有一个前驱predecessor。
2. 树中所有结点可以有零个或多个后继successor。

​                因此n个结点的树中有n-1条边。（除了根节点，头上都支出去一个）

overhanging / downwards Tree 倒悬树

### 1.2 树的基本术语

![image-20231128104053377](树与二叉树.assets/image-20231128104053377.png)

![image-20231128104949910](树与二叉树.assets/image-20231128104949910.png)结点：数据元素以及指向子树的分支

根节点：根节点没有前驱结点（非空树）

1. 结点的==度==degree：一个节点含有的<u>子树的个数</u>称为该节点的度； 如上图：A的度为2

2. 树的度degree：<u>一棵树中，最大的结点的度称为树的度</u>； 如上图：树的度为2

   

3. ==叶结点==leaf node ：度为0的结点称为叶结点； 如上图：G、H、I节点为叶节点

4. 非终端结点或分支结点branch nodes

   non-leaf node非叶节点：度不为0的节点； 如上图：B、D、C、E、F节点为分支节点

   ==（根结点之外的分支结点branch nodes称为<u>内部</u>结点）==internal nodes

   

5. **双亲**parent结点或父结点：若一个节点含有子节点，则这个节点称为其子节点

6. 父结点； 如上图：A是B的父节点

7. **孩子**child结点或子结点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点

   

8. **兄弟**Sibling结点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点

   同一双亲的所有子节点

   

9. 结点的**层次 **level：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；

10. level path:层次路径：从根节点到达某节点p所经过的所有结点（唯一）

11. **树**的高度或**深度depth**：树中节点的最大层次； 如上图：树的高度为4

    

12. **堂兄弟cousin**结点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点

13. 结点的**祖先**ancestor：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先

    ````
    结点p的层次路径上的所有结点（除了p）
    意味着p在层次路径上！！！
    ````

    

14. **子孙descendant**：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙

15. 森林：由m棵互不相交的树的集合称为森林；![image-20231128104209605](树与二叉树.assets/image-20231128104209605.png)

    ![image-20231128104425096](树与二叉树.assets/image-20231128104425096.png)

### 1.3 树结构与线性结构的比较

![image-20231128104620111](树与二叉树.assets/image-20231128104620111.png)

## 2.二叉树Binary Tree

### 2.1 概念

一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子树和右子树的二叉树组成。

&二叉树的特点：

~~~html
1. 每个结点最多有两棵子树，即二叉树不存在度大于2的结点。
2. 二叉树的子树有左右之分，其子树的次序不能颠倒。（有序树）
3. 根可以有空的左子树或空的右子树。

递归：二叉树的子树还是二叉树
~~~

==注意==：二叉树和树不一样![image-20231128105318828](树与二叉树.assets/image-20231128105318828.png)

==二叉树结点位置固定，可以是空，但不能没有位置==

![image-20231128105457235](树与二叉树.assets/image-20231128105457235.png)

![image-20231128105533909](树与二叉树.assets/image-20231128105533909.png)

Full binary Tree

Complete Tree

###### ！！！![image-20231128110356109](树与二叉树.assets/image-20231128110356109.png)

![image-20231128110458005](树与二叉树.assets/image-20231128110458005.png)

### 2.2常考性质properties

````
1.在非空二叉树中，第i层上至多有2^(i-1)个结点（i>=1）
2.在深度depth=k的二叉树至多含有2^k-1个结点（k>=1）
默认满二叉树，然后等比数列求和
3.对任何一棵二叉树，若其叶子结点数（度=0）为n0，度为2的结点数为n2，则
n0=n2+1(见考点1)
叶子结点比二分支结点多一个
（数的结点数=总度数+1【加上根节点】）
4.见常见考点1
5.见概念的！！！
````

![image-20231212175110743](树与二叉树.assets/image-20231212175110743.png)

![image-20231212175147957](树与二叉树.assets/image-20231212175147957.png)

![image-20231212175210282](树与二叉树.assets/image-20231212175210282.png)

向上取整

![image-20231212175407044](树与二叉树.assets/image-20231212175407044.png)

向下取整

![image-20231212175533719](树与二叉树.assets/image-20231212175533719.png)

###### ！！！![image-20231212175627736](树与二叉树.assets/image-20231212175627736.png)

![image-20231212175741462](树与二叉树.assets/image-20231212175741462.png)

![image-20231212175749298](树与二叉树.assets/image-20231212175749298.png)

### 2.3 存储结构

+ ###### 顺序存储 Sequential Storage Structure![image-20231212175900291](树与二叉树.assets/image-20231212175900291.png)

###### 1![image-20231212180033966](树与二叉树.assets/image-20231212180033966.png)

如果不是完全二叉树，无法按照结点编号反映出结点的逻辑关系；

![image-20231212180300002](树与二叉树.assets/image-20231212180300002.png)

可以通过结点找到对应的左孩子，右孩子，从而通过isempty的布偶值来判断该值是否存在：

 空间闲置![image-20231212180450870](树与二叉树.assets/image-20231212180450870.png)

![image-20231212180511234](树与二叉树.assets/image-20231212180511234.png)

+ ###### 链式存储 Linked Storage Structure

![image-20231212180532662](树与二叉树.assets/image-20231212180532662.png)

没有孩子的话，可以设置为NULL；

![image-20231212180801567](树与二叉树.assets/image-20231212180801567.png)

一共有n个结点，每个结点两个指针，则一共有2n个指针域

除了根结点，每个结点的上方都有一个指针指向它，所以，n-1个指针是使用的，则有n+1个指针是空的（空链域）

![image-20231212181103125](树与二叉树.assets/image-20231212181103125.png)

![image-20231212181156537](树与二叉树.assets/image-20231212181156537.png)

### 2.4 二叉树的遍历Traversal

![image-20231212181309918](树与二叉树.assets/image-20231212181309918.png)

二叉树的递归特性

1. 空二叉树：什么都不用做
2. 二叉树，递归完成三种遍历

![image-20231212181342705](树与二叉树.assets/image-20231212181342705.png)

![image-20231212181623089](树与二叉树.assets/image-20231212181623089.png)

**代码遍历**

![image-20231212181657276](树与二叉树.assets/image-20231212181657276.png)

**（遍历左右子树时，采用递归的方法）**

![image-20231212182039968](树与二叉树.assets/image-20231212182039968.png)

![image-20231212182117524](树与二叉树.assets/image-20231212182117524.png)

画路径的方法是一样的，

先序：第一次路过

中序：第二次路过

后序：第三次路过

![image-20231212182256345](树与二叉树.assets/image-20231212182256345.png)

后序遍历算法的变换式

![image-20231212182343741](树与二叉树.assets/image-20231212182343741.png)

### 2.5 二叉树的层序遍历

![image-20231212182604488](树与二叉树.assets/image-20231212182604488.png)

![image-20231212182726124](树与二叉树.assets/image-20231212182726124.png)

### 2.6 由遍历序列推出二叉树结构

![image-20231212183021431](树与二叉树.assets/image-20231212183021431.png)

（==一定要有中序遍历==）

注意验证

前序可以知道==根节点位置==，中序对左右子树做划分

![image-20231212183432776](树与二叉树.assets/image-20231212183432776.png)

![image-20231212183553004](树与二叉树.assets/image-20231212183553004.png)

### 2.7 线索二叉树Threaded binary tree

#### 定义--flag field

#### （0是孩子，1是线索thread---precursor/successor）

![image-20231212183646453](树与二叉树.assets/image-20231212183646453.png)

![image-20231212190903613](树与二叉树.assets/image-20231212190903613.png)

当孩子指针不指向孩子，而指向前驱或者后继

空链域-->线索化：更方便找前驱和后继，并且遍历也更加的方便了

![image-20231212191202052](树与二叉树.assets/image-20231212191202052.png)

![image-20231212191220950](树与二叉树.assets/image-20231212191220950.png)

![image-20231212191532880](树与二叉树.assets/image-20231212191532880.png)

#### 二叉树的线索化

1.先找前驱后继![image-20231212191737341](树与二叉树.assets/image-20231212191737341.png)

![image-20231212192249672](树与二叉树.assets/image-20231212192249672.png)

![image-20231212192259527](树与二叉树.assets/image-20231212192259527.png)

先序线索化：可能有转圈问题![image-20231212192748134](树与二叉树.assets/image-20231212192748134.png)

![image-20231212192755595](树与二叉树.assets/image-20231212192755595.png)

![image-20231212192827703](树与二叉树.assets/image-20231212192827703.png)

![image-20231212192900599](树与二叉树.assets/image-20231212192900599.png)

#### 线索二叉树找前驱/后继

中序找后继

右子树的最左的孩子![image-20231212193413704](树与二叉树.assets/image-20231212193413704.png)

中序找前驱

左子树的最右的孩子

![image-20231212193724437](树与二叉树.assets/image-20231212193724437.png)

先序找后继：

假设有左孩子，则是左孩子，没有左孩子就是右孩子，没有左右孩子，则是右孩子，指向后继结点

（先判断是否有右孩子，没有右孩子的话，线索化直接指向后继）

先序找前驱：（三叉链表）

先判断有没有左孩子--父节点

![image-20231212194532977](树与二叉树.assets/image-20231212194532977.png)

![image-20231212194815365](树与二叉树.assets/image-20231212194815365.png)

## 3.树的存储结构

### 3.1 树的逻辑结构

#### 双亲表示法（顺序存储）

每个结点中保存指向双亲的“指针”

结点的数组

指向双亲的指针--双亲的位置域

![image-20231212195128113](树与二叉树.assets/image-20231212195128113.png)

#### 孩子标识法（顺+链）

顺序存储各个结点，每个结点中保存孩子链表头指针

![image-20231212200452619](树与二叉树.assets/image-20231212200452619.png)

![image-20231212200503299](树与二叉树.assets/image-20231212200503299.png)

链表中只保存了所有的指针

#### 孩子兄弟表示法（链式）

![image-20231212200944298](树与二叉树.assets/image-20231212200944298.png)

### 3.2 森林和二叉树的转换

![image-20231212201204501](树与二叉树.assets/image-20231212201204501.png)

![image-20231212201224170](树与二叉树.assets/image-20231212201224170.png)

![image-20231212201257149](树与二叉树.assets/image-20231212201257149.png)

### 3.3 树、森林的遍历

![image-20231212201348329](树与二叉树.assets/image-20231212201348329.png)

#### 树的遍历

##### 深度优先遍历

![image-20231212201535073](树与二叉树.assets/image-20231212201535073.png)

![image-20231212201542089](树与二叉树.assets/image-20231212201542089.png)

![image-20231212201549190](树与二叉树.assets/image-20231212201549190.png)

![image-20231212201712809](树与二叉树.assets/image-20231212201712809.png)

![image-20231212201719410](树与二叉树.assets/image-20231212201719410.png)

##### 广度优先遍历

层序遍历:用队列实现

![image-20231212202143341](树与二叉树.assets/image-20231212202143341.png)

#### 森林的遍历

![image-20231212202230164](树与二叉树.assets/image-20231212202230164.png)

先序遍历森林==依次对各个树进行先根遍历

​                         ==对相应的二叉树（先进行转化）进行先序遍历

中序遍历森林 = =依次对各个树进行==后根遍历==

​                         ==对相应的二叉树（先进行转化）进行<u>中序遍历</u>

==孩子兄弟表示法==

![image-20231212202612072](树与二叉树.assets/image-20231212202612072.png)

## 4.哈夫曼树

```
一些基本概念：
Node Path：结点路径
Path Length:路径长度==边的树木
Path length of Tree:树的路径长度（从树根到每一个结点的路径长度之和）

Weighted Path Length of Node:结点的带权路径长度
从该结点到树的根节点之间的路径长度与结点权值的乘积
Weight:权值--各种开销、代价、频度等的抽象称呼
WPL of Tree:树的WPL，树中所有叶结点带权路径长度之和

Huffman Tree：最优二叉树（拥有最小的带权路径长度）
```

![image-20231218193842686](树与二叉树.assets/image-20231218193842686.png)

![image-20231218193927204](树与二叉树.assets/image-20231218193927204.png)

![image-20231218194156356](树与二叉树.assets/image-20231218194156356.png)

![image-20231218194226015](树与二叉树.assets/image-20231218194226015.png)

哈夫曼树不唯一，但是最小带权路径长度是唯一的

#### 哈夫曼编码（应用）

![image-20231218200101855](树与二叉树.assets/image-20231218200101855.png)

可用于：数据的压缩

Prefix Code:前缀编码

编码长短不等，且任意字符的编码都不是另一个字符编码的前缀

So，每一个字符都是叶子结点，不可能出现在根结点到其他字符结点的路径上，则不会出现前缀可能。
